(0 e 14 (goal-is-to {argument1 ?chest, action unlock} nil) hold-chest-to-put-on-floor)
(1 i 54 (thing {on-top-of ?surf, weight light, name ?chest} (not= ?surf floor)))
(2 x 84 (monkey {holding ?thing} ((not= ?thing ?chest) (not-exists goal-is-to action hold argument1 ?chest))) hold-chest-to-put-on-floor 0 ((rete.core/asser goal-is-to action hold argument1 ?chest)))
(3 e 14 (goal-is-to {argument1 ?chest, action unlock} nil) put-chest-on-floor)
(4 i 84 (monkey {on-top-of ?on, holding ?chest, location ?place} nil))
(5 x 85 (thing {name ?chest} nil) put-chest-on-floor 0 ((println (str "Monkey throws the " ?chest " off the " ?on " onto the floor.")) (rete.core/modify :FIDS 1 holding blank) (rete.core/modify :FIDS 2 location ?place on-top-of floor)))
(6 e 14 (goal-is-to {argument1 ?obj, action unlock} nil) get-key-to-unlock)
(7 i 12 (thing {on-top-of floor, name ?obj} nil))
(8 i 46 (chest {name ?obj, unlocked-by ?key} nil))
(9 x 84 (monkey {holding ?thing} ((not= ?thing ?key) (not-exists goal-is-to action hold argument1 ?key))) get-key-to-unlock 0 ((rete.core/asser goal-is-to action hold argument1 ?key)))
(10 e 14 (goal-is-to {argument1 ?chest, action unlock} nil) move-to-chest-with-key)
(11 i 84 (monkey {holding ?key, location ?mplace} nil))
(12 i 12 (thing {on-top-of floor, name ?chest, location ?cplace} (not= ?cplace ?mplace)))
(13 x 46 (chest {name ?chest, unlocked-by ?key} (not-exists goal-is-to action walk-to argument1 ?cplace)) move-to-chest-with-key 0 ((rete.core/asser goal-is-to action walk-to argument1 ?cplace)))
(14 e 14 (goal-is-to {argument1 ?name, action unlock} nil) unlock-chest-with-key)
(15 i 46 (chest {contents ?contents, name ?name, unlocked-by ?key} nil))
(16 i 85 (thing {on-top-of ?on, name ?name, location ?place} nil))
(17 x 84 (monkey {on-top-of ?on, holding ?key, location ?place} nil) unlock-chest-with-key 0 ((println (str "Monkey opens the " ?name " with the " ?key " revealing the " ?contents ".")) (rete.core/modify :FIDS 1 contents nothing) (rete.core/asser thing name ?contents location ?place on-top-of ?name weight light) (rete.core/retract :FIDS 0)))
(18 e 39 (goal-is-to {argument1 ?obj, action hold} nil) unlock-chest-to-hold-object)
(19 x 46 (chest {contents ?obj, name ?chest} (not-exists goal-is-to action unlock argument1 ?chest)) unlock-chest-to-hold-object 0 ((rete.core/asser goal-is-to action unlock argument1 ?chest)))
(20 e 39 (goal-is-to {argument1 ?obj, action hold} nil) use-ladder-to-hold)
(21 x 27 (thing {on-top-of ceiling, weight light, name ?obj, location ?place} ((not-exists thing name ladder location ?place) (not-exists goal-is-to action move argument1 ladder argument2 ?place))) use-ladder-to-hold 0 ((rete.core/asser goal-is-to action move argument1 ladder argument2 ?place)))
(22 e 39 (goal-is-to {argument1 ?obj, action hold} nil) climb-ladder-to-hold)
(23 i 27 (thing {on-top-of ceiling, weight light, name ?obj, location ?place} nil))
(24 i 24 (thing {on-top-of floor, name ladder, location ?place} nil))
(25 x 84 (monkey {on-top-of ?s} ((not= ?s ladder) (not-exists goal-is-to action on argument1 ladder))) climb-ladder-to-hold 0 ((rete.core/asser goal-is-to action on argument1 ladder)))
(26 e 39 (goal-is-to {argument1 ?name, action hold} nil) grab-object-from-ladder)
(27 i 27 (thing {on-top-of ceiling, weight light, name ?name, location ?place} nil))
(28 i 28 (thing {name ladder, location ?place} nil))
(29 x 29 (monkey {on-top-of ladder, holding blank, location ?place} nil) grab-object-from-ladder 0 ((println (str "Monkey grabs the " ?name ".")) (rete.core/modify :FIDS 1 location held on-top-of held) (rete.core/modify :FIDS 3 holding ?name) (rete.core/retract :FIDS 0)))
(30 e 39 (goal-is-to {argument1 ?obj, action hold} nil) climb-to-hold)
(31 i 54 (thing {on-top-of ?on, weight light, name ?obj, location ?place} (not= ?on ceiling)))
(32 x 84 (monkey {on-top-of ?surf, location ?place} ((not= ?surf ?on) (not-exists goal-is-to action on argument1 ?on))) climb-to-hold 0 ((rete.core/asser goal-is-to action on argument1 ?on)))
(33 e 39 (goal-is-to {argument1 ?obj, action hold} nil) walk-to-hold)
(34 i 54 (thing {on-top-of ?surf, weight light, name ?obj, location ?place} (not= ?surf ceiling)))
(35 x 84 (monkey {location ?loc} ((not= ?loc ?place) (not-exists goal-is-to action walk-to argument1 ?place))) walk-to-hold 0 ((rete.core/asser goal-is-to action walk-to argument1 ?place)))
(36 e 39 (goal-is-to {argument1 ?obj, action hold} nil) drop-to-hold)
(37 i 54 (thing {on-top-of ?on, weight light, name ?obj, location ?place} nil))
(38 x 84 (monkey {on-top-of ?on, holding ?hold, location ?place} ((not= ?hold blank) (not-exists goal-is-to action hold argument1 blank))) drop-to-hold 0 ((rete.core/asser goal-is-to action hold argument1 blank)))
(39 e 39 (goal-is-to {argument1 ?name, action hold} nil) grab-object)
(40 i 54 (thing {on-top-of ?on, weight light, name ?name, location ?place} nil))
(41 x 78 (monkey {on-top-of ?on, holding blank, location ?place} nil) grab-object 0 ((println (str "Monkey grabs the " ?name ".")) (rete.core/modify :FIDS 1 location held on-top-of held) (rete.core/modify :FIDS 2 holding ?name) (rete.core/retract :FIDS 0)))
(42 e 42 (goal-is-to {argument1 blank, action hold} nil) drop-object)
(43 i 84 (monkey {on-top-of ?on, holding ?name, location ?place} (not= ?name blank)))
(44 x 85 (thing {name ?name} nil) drop-object 0 ((println (str "Monkey drops the " ?name ".")) (rete.core/modify :FIDS 1 holding blank) (rete.core/modify :FIDS 2 location ?place on-top-of ?on) (rete.core/retract :FIDS 0)))
(45 e 55 (goal-is-to {argument1 ?obj, argument2 ?place, action move} nil) unlock-chest-to-move-object)
(46 x 46 (chest {contents ?obj, name ?chest} (not-exists goal-is-to action unlock argument1 ?chest)) unlock-chest-to-move-object 0 ((rete.core/asser goal-is-to action unlock argument1 ?chest)))
(47 e 55 (goal-is-to {argument1 ?obj, argument2 ?place, action move} nil) hold-object-to-move)
(48 i 54 (thing {weight light, name ?obj, location ?loc} (not= ?loc ?place)))
(49 x 84 (monkey {holding ?hold} ((not= ?hold ?obj) (not-exists goal-is-to action hold argument1 ?obj))) hold-object-to-move 0 ((rete.core/asser goal-is-to action hold argument1 ?obj)))
(50 e 55 (goal-is-to {argument1 ?obj, argument2 ?place, action move} nil) move-object-to-place)
(51 x 84 (monkey {holding ?obj, location ?loc} ((not= ?loc ?place) (not-exists goal-is-to action walk-to argument1 ?place))) move-object-to-place 0 ((rete.core/asser goal-is-to action walk-to argument1 ?place)))
(52 e 55 (goal-is-to {argument1 ?name, argument2 ?place, action move} nil) drop-object-once-moved)
(53 i 84 (monkey {holding ?obj, location ?place} nil))
(54 x 54 (thing {weight light, name ?name} nil) drop-object-once-moved 0 ((println (str "Monkey drops the " ?name ".")) (rete.core/modify :FIDS 1 holding blank) (rete.core/modify :FIDS 2 location ?place on-top-of floor) (rete.core/retract :FIDS 0)))
(55 e 55 (goal-is-to {argument1 ?obj, argument2 ?place, action move} nil) already-moved-object)
(56 x 85 (thing {name ?obj, location ?place} nil) already-moved-object 0 ((rete.core/retract :FIDS 0)))
(57 e 63 (goal-is-to {argument1 ?place, action walk-to} nil) already-at-place)
(58 x 84 (monkey {location ?place} nil) already-at-place 0 ((rete.core/retract :FIDS 0)))
(59 e 63 (goal-is-to {argument1 ?place, action walk-to} nil) get-on-floor-to-walk)
(60 x 84 (monkey {on-top-of ?surf, location ?loc} ((not= ?loc ?place) (not= ?surf floor) (not-exists goal-is-to action on argument1 floor))) get-on-floor-to-walk 0 ((rete.core/asser goal-is-to action on argument1 floor)))
(61 e 63 (goal-is-to {argument1 ?place, action walk-to} nil) walk-holding-nothing)
(62 x 62 (monkey {on-top-of floor, holding blank, location ?loc} (not= ?loc ?place)) walk-holding-nothing 0 ((println (str "Monkey walks to " ?place ".")) (rete.core/modify :FIDS 1 location ?place) (rete.core/retract :FIDS 0)))
(63 e 63 (goal-is-to {argument1 ?place, action walk-to} nil) walk-holding-object)
(64 x 64 (monkey {on-top-of floor, holding ?obj, location ?loc} ((not= ?loc ?place) (not= ?obj blank))) walk-holding-object 0 ((println (str "Monkey walks to " ?place " holding the " ?obj ".")) (rete.core/modify :FIDS 1 location ?place) (rete.core/retract :FIDS 0)))
(65 e 65 (goal-is-to {argument1 floor, action on} nil) jump-onto-floor)
(66 x 84 (monkey {on-top-of ?on} (not= ?on floor)) jump-onto-floor 0 ((println (str "Monkey jumps off the " ?on " onto the floor.")) (rete.core/modify :FIDS 1 on-top-of floor) (rete.core/retract :FIDS 0)))
(67 e 79 (goal-is-to {argument1 ?obj, action on} nil) walk-to-place-to-climb)
(68 i 85 (thing {name ?obj, location ?place} nil))
(69 x 84 (monkey {location ?loc} ((not= ?loc ?place) (not-exists goal-is-to action walk-to argument1 ?place))) walk-to-place-to-climb 0 ((rete.core/asser goal-is-to action walk-to argument1 ?place)))
(70 e 79 (goal-is-to {argument1 ?obj, action on} nil) drop-to-climb)
(71 i 85 (thing {name ?obj, location ?place} nil))
(72 x 84 (monkey {holding ?hold, location ?place} ((not= ?hold blank) (not-exists goal-is-to action hold argument1 blank))) drop-to-climb 0 ((rete.core/asser goal-is-to action hold argument1 blank)))
(73 e 79 (goal-is-to {argument1 ?obj, action on} nil) climb-indirectly)
(74 i 85 (thing {on-top-of ?on, name ?obj, location ?place} nil))
(75 x 78 (monkey {on-top-of ?on2, holding blank, location ?place} ((not= ?on2 ?on) (not= ?on2 ?obj) (not-exists goal-is-to action on argument1 ?on))) climb-indirectly 0 ((rete.core/asser goal-is-to action on argument1 ?on)))
(76 e 79 (goal-is-to {argument1 ?obj, action on} nil) climb-directly)
(77 i 85 (thing {on-top-of ?on, name ?obj, location ?place} nil))
(78 x 78 (monkey {on-top-of ?on, holding blank, location ?place} nil) climb-directly 0 ((println (str "Monkey climbs onto the " ?obj ".")) (rete.core/modify :FIDS 2 on-top-of ?obj) (rete.core/retract :FIDS 0)))
(79 e 79 (goal-is-to {argument1 ?obj, action on} nil) already-on-object)
(80 x 84 (monkey {on-top-of ?obj} nil) already-on-object 0 ((rete.core/retract :FIDS 0)))
(81 e 83 (goal-is-to {argument1 ?obj, action eat} nil) hold-to-eat)
(82 x 84 (monkey {holding ?h} ((not= ?h ?obj) (not-exists goal-is-to action hold argument1 ?obj))) hold-to-eat 0 ((rete.core/asser goal-is-to action hold argument1 ?obj)))
(83 e 83 (goal-is-to {argument1 ?name, action eat} nil) satisfy-hunger)
(84 i 84 (monkey {holding ?name} nil))
(85 x 85 (thing {name ?name} nil) satisfy-hunger 0 ((println (str "Monkey eats the " ?name ".")) (rete.core/modify :FIDS 1 holding blank) (rete.core/retract :FIDS 0 2)))
